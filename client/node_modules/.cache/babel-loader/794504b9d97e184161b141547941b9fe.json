{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nimport { convenient } from './gradation';\n/**\r\n * Takes seconds `elapsed` and measures them against\r\n * `gradation` to return the suitable `gradation` step.\r\n *\r\n * @param {number} elapsed - Time interval (in seconds)\r\n *\r\n * @param {string[]} units - A list of allowed time units\r\n *                           (e.g. ['second', 'minute', 'hour', …])\r\n *\r\n * @param {Object} [gradation] - Time scale gradation steps.\r\n *\r\n *                               E.g.:\r\n *                               [\r\n *                                 { unit: 'second', factor: 1 },\r\n *                                 { unit: 'minute', factor: 60, threshold: 60 },\r\n *                                 { format(), threshold: 24 * 60 * 60 },\r\n *                                 …\r\n *                               ]\r\n *\r\n * @return {?Object} `gradation` step.\r\n */\n\nexport default function grade(elapsed, now, units) {\n  var gradation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : convenient; // Leave only allowed time measurement units.\n  // E.g. omit \"quarter\" unit.\n\n  gradation = getAllowedSteps(gradation, units); // If no steps of gradation fit the conditions\n  // then return nothing.\n\n  if (gradation.length === 0) {\n    return;\n  } // Find the most appropriate gradation step\n\n\n  var i = findGradationStep(elapsed, now, gradation);\n  var step = gradation[i]; // If time elapsed is too small and even\n  // the first gradation step doesn't suit it\n  // then return nothing.\n\n  if (i === -1) {\n    return;\n  } // Apply granularity to the time amount\n  // (and fall back to the previous step\n  //  if the first level of granularity\n  //  isn't met by this amount)\n\n\n  if (step.granularity) {\n    // Recalculate the elapsed time amount based on granularity\n    var amount = Math.round(elapsed / step.factor / step.granularity) * step.granularity; // If the granularity for this step\n    // is too high, then fallback\n    // to the previous step of gradation.\n    // (if there is any previous step of gradation)\n\n    if (amount === 0 && i > 0) {\n      return gradation[i - 1];\n    }\n  }\n\n  return step;\n}\n/**\r\n * Gets threshold for moving from `fromStep` to `next_step`.\r\n * @param  {Object} fromStep - From step.\r\n * @param  {Object} next_step - To step.\r\n * @param  {number} now - The current timestamp.\r\n * @return {number}\r\n * @throws Will throw if no threshold is found.\r\n */\n\nfunction getThreshold(fromStep, toStep, now) {\n  var threshold; // Allows custom thresholds when moving\n  // from a specific step to a specific step.\n\n  if (fromStep && (fromStep.id || fromStep.unit)) {\n    threshold = toStep[\"threshold_for_\".concat(fromStep.id || fromStep.unit)];\n  } // If no custom threshold is set for this transition\n  // then use the usual threshold for the next step.\n\n\n  if (threshold === undefined) {\n    threshold = toStep.threshold;\n  } // Convert threshold to a number.\n\n\n  if (typeof threshold === 'function') {\n    threshold = threshold(now);\n  } // Throw if no threshold is found.\n\n\n  if (fromStep && typeof threshold !== 'number') {\n    // Babel transforms `typeof` into some \"branches\"\n    // so istanbul will show this as \"branch not covered\".\n\n    /* istanbul ignore next */\n    var type = _typeof(threshold);\n\n    throw new Error(\"Each step of a gradation must have a threshold defined except for the first one. Got \\\"\".concat(threshold, \"\\\", \").concat(type, \". Step: \").concat(JSON.stringify(toStep)));\n  }\n\n  return threshold;\n}\n/**\r\n * @param  {number} elapsed - Time elapsed (in seconds).\r\n * @param  {number} now - Current timestamp.\r\n * @param  {Object} gradation - Gradation.\r\n * @param  {number} i - Gradation step currently being tested.\r\n * @return {number} Gradation step index.\r\n */\n\n\nfunction findGradationStep(elapsed, now, gradation) {\n  var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0; // If the threshold for moving from previous step\n  // to this step is too high then return the previous step.\n\n  if (elapsed < getThreshold(gradation[i - 1], gradation[i], now)) {\n    return i - 1;\n  } // If it's the last step of gradation then return it.\n\n\n  if (i === gradation.length - 1) {\n    return i;\n  } // Move to the next step.\n\n\n  return findGradationStep(elapsed, now, gradation, i + 1);\n}\n/**\r\n * Leaves only allowed gradation steps.\r\n * @param  {Object[]} gradation\r\n * @param  {string[]} units - Allowed time units.\r\n * @return {Object[]}\r\n */\n\n\nfunction getAllowedSteps(gradation, units) {\n  return gradation.filter(function (_ref) {\n    var unit = _ref.unit; // If this step has a `unit` defined\n    // then this `unit` must be in the list of `units` allowed.\n\n    if (unit) {\n      return units.indexOf(unit) >= 0;\n    } // A gradation step is not required to specify a `unit`.\n    // E.g. for Twitter gradation it specifies `format()` instead.\n\n\n    return true;\n  });\n}","map":null,"metadata":{},"sourceType":"module"}